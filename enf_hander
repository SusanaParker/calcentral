#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'

require 'eventmachine'
require 'stomp'
require 'yaml'
require 'deep_open_struct'
require 'active_support/core_ext/hash'
require 'httparty'
require 'logger'

class Settings
  attr_reader :env

  def initialize(env)
    @env = env
  end

  def merged
    @merged ||= Hash.new.tap do |settings|
      config_files.each do |file|
        if file && File.exists?(file)
          result = YAML.load_file(file.to_s)
          settings.deep_merge!(result) if result
        end
      end
    end
  end

  def config_files
    [
      File.join(config_dir, "settings.local.yml"),
      File.join(config_dir, "#{env}.local.yml"),
    ]
  end

  def config_dir
    path = ENV.fetch('CALCENTRAL_CONFIG_DIR') { File.join(ENV["HOME"], ".calcentral_config") }
    File.expand_path(path) if File.exists?(path)
  end
end

module ENF
  class Handler
    attr_reader :settings
    attr_reader :retry_queue
    attr_reader :logger

    def initialize(settings, logger)
      @settings = settings
      @retry_queue = []
      @logger = logger
    end

    def start
      @running = true

      queues.each do |queue|
        client.subscribe(queue) do |message|
          handle(message)
        end
      end
    end

    def handle(message, retries=0)
      response = HTTParty.post(post_endpoint, {
        body: JSON.generate({
          enf: JSON.parse(message.body)
        }),
        headers: headers
      })

      if response.success?
        logger.info "Message id: #{message_id(message)} posted successfully (#{retries} retry attempts)"
      else
        logger.error "Post response failed with HTTP status #{response.code} for message id: #{message_id(message)} (#{retries} retry attempts)"
        message_failed(message, retries)
      end
    rescue Errno::ECONNREFUSED
      logger.error "Post connection refused for message id: #{message_id(message)} (#{retries} retry attempts)"
      message_failed(message, retries)
    end

    def message_failed(message, retries)
      retry_queue.push([message, retries])
    end

    def process_failures!
      while retry_queue.length > 0
        message, retries = *retry_queue.pop
        yield message, retries
      end
    end

    def processing_retries?
      @processing_retries
    end

    private



    delegate :key, :username, :password, :host, :port, :queues, :post_to, to: :settings

    def client
      @client ||= ::Stomp::Client.new(username, password, host, port)
    end

    def headers
      {
        'Content-Type' => 'application/json',
        'X-API-KEY' => key
      }
    end

    def post_endpoint
      "#{post_to}/api/enfs"
    end

    def message_id(message)
      message.headers['message-id']
    end
  end
end

EventMachine.run {
  settings = ::DeepOpenStruct.new(Settings.new('development').merged).ist_jms

  logger = if (settings.log_to)
    Logger.new(settings.log_to, 'daily')
  else
    Logger.new(STDOUT)
  end

  handler = ENF::Handler.new(settings, logger)
  handler.start

  EventMachine.add_periodic_timer(1) do
    handler.process_failures! do |message, retries|
      if retries < settings.max_retries || 4
        delay = (settings.initial_retry_timeout || 10) * 2**retries
        logger.info "Retrying message #{message.headers['message-id']} in #{delay} seconds"

        EventMachine.add_timer(delay) do
          handler.handle(message, retries + 1)
        end
      else
      end
    end
  end

  logger.info "Ready"
}
